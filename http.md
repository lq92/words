## HTTP
### TCP/IP协议族
    TCP/IP协议族按层次可以分为：应用层、传输层、网络层和数据链路层
      * 应用层——决定了向用户提供应用服务时通信的活动(FTP/DNS/HTTP)
      * 传输层——对上层应用层，提供处于网络连接中两台计算机之间的数据传输(TCP传输控制协议，UDP用户数据报协议)
      * 网络层——数据包是网络传输的最小单位，网络层用来处理网络上流动的数据包，该层规定了通过怎样的路径到达对方计算机，并将数据包传递给对方，与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多选项内选择一条传输路线
      * 数据链路层——用来处理连接网络的硬件部分，包含操作系统、硬件的设备驱动、网卡、光纤等物理可见部分
    在用TCP/IP协议族进行网络通信时，客户端从应用层往下走，服务器端从数据链路层往上走
    举例：首先作为发送端的客户端在应用层(HTTP协议)发出一个想看某个web页面的HTTP请求；接着为了传输方便，在传输层(TCP协议)把从应用层接收到的数据(HTTP请求报文)进行分割，并在报文上打上标记序号及端口号后转发给网络层；在网络层(IP协议)，增加作为通信目的地的MAC地址后转发给链路层，这样发往网络的通信请求就准备齐全了；服务器在链路层接收到数据，按顺序向上发送，一直到应用层，当到达应用层，才算真正接收由客户端发过来的HTTP请求 
### 确保可靠性的TCP协议
    TCP位于传输层，提供可靠的字节流服务(为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理)，而可靠的传输服务是指，能够把数据准确可靠的传递给对方。总结起来，TCP协议为了能够传递大块数据所以把数据分割，而且会确认数据最终是否送达到对方
    TCP的三次握手：发送端首先会发送一个带SYN标志的数据包给对方，接收端接收后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后发送方再回传一个带有ACK标志的数据包，代表结束。
### DNS——应用层协议
    用于域名到ip地址间的解析服务
### URI——统一资源标识符
    URI用字符串标识某一互联网资源，而URL表示资源的地点(互联网上所处的位置),URL是URI的子集
    URI格式：http://username:password@www.example.com:80/dir/index.html?uid=1#hash
### HTTP协议
    http协议规定：请求从客户端发出，服务器端接收响应并返回，请求都是从客户端开始建立通信，服务器端在没收到请求不会发送响应
        * 请求报文构成——请求的方法、请求的URI、HTTP版本号、可选的请求首部字段和内容实体构成
            ```
                POST / HTTP/1.1      // 方法、URI、HTTP协议
                // 请求首部字段
                Host: www.baidu.com
                Connection: keep-alive
                Content-Type: application/x-www-form-urlencoded
                Content-Length: 16
                // 内容实体
                name=ueno&age=37
            ```
        * 响应报文——由HTTP版本、处理请求的状态码和原因短语、响应的日期时间、资源实体的主体
            ```
                HTTP/1.1 200 OK
                // 响应首部字段
                Date: Tue, 10 jul 2018 08:00:00 GMT
                Content-Length: 362
                Content-Type: text/html
                CR + LF
                // 资源实体
                <html>
                .....
            ```
    http协议是无状态的协议，自身不对请求和响应之间的通信状态进行保存，协议对于发送过的请求或响应都不做持久化处理，但是为了实现保持状态功能，于是引入了Cookie技术，再加上HTTP协议通信，就可以管理状态了
    **HEAD方法**——和GET方法一样，只是不返回报文主体部分
    **OPTIONS方法**——用来查询针对请求URI指定的资源支持的方法
    **持久连接**——当请求一个HTML页面的同时也会请求该HTML页面里包含的其他资源，因此每次请求都会导致无谓的TCP连接建立和断开，增加通信量的开销，持久连接的特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态
    **管线化**——持久连接使得多数请求以管线化方式发送成为可能，以前发送请求后需等待并收到响应，才发送下一个请求，管线化使得可以同时并行发送多个请求，而不需要一个接一个等待响应。
    **Cookie**——会根据从服务器端发送的响应报文内的一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送，服务器发现客户端发送过来的Cookie后，会检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息
        ```
            // 请求报文，没有Cookie信息
            GET / HTTP/1.1
            Host: www.taobao.com
            // 响应报文，SetCookie
            HTTP/1.1 200 OK
            Date: 
            Server: Apache
            <Set-Cookie: sid=1342077170226724; path=/; expires=Wed, 10-Oct-12 08:00:00 CMT>
            Content-Type: text/plain; charset=UTF-8
            // 请求报文(自动发送保存着的Cookie信息)
            GET / HTTP/1.1
            Host: www.taobao.com
            Cookie: sid=1342077170226724
        ```
### HTTP报文
    用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫请求报文，服务器端的叫响应报文。HTTP报文本身由多行(用CR+LF作换行符)数据构成的字符串文本。
    HTTP报文可分为报文首部和报文主体两部分，中间用CR+LF分割，报文主体可无
    报文首部：请求首部字段、响应首部字段、通用首部字段、实体首部字段
    **编码提升传输速率**
      HTTP在传输的时候可以原样传输也可以传输过程中通过编码提升传输速率，通过在传输时编码，能有效处理大量的访问请求，但是编码的操作需要计算机来完成，会消耗更多的CPU资源
      常用编码内容：gzip、compress、deflate、identity(不进行编码)
    ** 分块传输编码 **
      在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分割多块，能够让浏览器逐步显示页面
    ** 发送多种数据的多部分对象集合 **
      允许处理不同类型的数据。
      多部分对象集合包含的对象如下：
        `multipart/form-data`——在web表单文件上传时使用
        `multipart/byteranges`——状态码206，响应报文包含了多个范围的内容时使用
      在HTTP报文中使用多部分对象集合时，需在首部字段里加上Content-type
    ** 获取部分内容的范围请求 **
      使用范围请求，只请求部分字节内的资源，在请求首部字段指定Range
        `Range: bytes=5001-10000`
        `Range: bytes=5001-`
        `Range: bytes=-3000, 5000-7000` 从一开始到3000字节和5000-7000字节
      如何服务器无法响应范围请求，会返回200和完整的实体内容
    ** 内容协商返回最合适的内容 **
      同一个web网站有可能存在多份相同内容的页面，比如英语版和中文版，当浏览器默认语言为英语或中文，访问相同URI的web页面时，则会显示对应语言的web页面，这样的机制叫内容协商。
      内容协商会以响应资源的语言、字符集和编码方式等作为判断依据。
      包含在请求报文中的首部字段：
      Accept
      Accept-Charset
      Accept-Encoding
      Accept-Language
      Content-Language
      内容协商有以下3种类型：
        服务器驱动协商：以请求的首部字段为参考，在服务器端自动处理，对于用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。
        客户端驱动协商：由客户端进行内容协商的方式，用户从浏览器显示的可选项列表中手动选择，还可以利用js脚本在web页面上自动选择，比如按OS的类型和浏览器类型，自动切换成PC版页面或手机版页面。
        透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。
### HTTP状态
    * 响应的状态码——数字中的第一位指定响应类别，后两位无分类
              |类别|原因短句|
          |----|----|----|
          |1xx|信息性状态码|接收的请求正在处理|
          |2xx|成功状态码|请求正常处理完毕|
          |3xx|重定向状态码|需要进行附加操作以完成请求|
          |4xx|客户端错误状态码|服务器无法处理请求|
          |5xx|服务器错误状态码|服务器处理请求出错|
    * 常用状态码及说明
        200 OK 成功
        204 No Content：表示请求成功处理，但是响应报文中没有实体的主体内容
        206 Partial Content：表示客户端进行了范围请求(Range)，而服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容
        301 永久性重定向：表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI，如果对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存
        302 临时性重定向：表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问
        304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，简单表达：客户端已经执行了GET，但文件未变化，附带条件请求指采用GET方法的请求报文中包含If-Match/If-Modified-Since/If-None-Match/If-Range/If-Unmodified-Since中任一首部
        400 表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求
        401 未授权
        403 禁止访问资源，服务器端可以在响应的实体的主体部分中作出说明
        404 表示服务器上无法找到请求的资源
        500 表示服务器在执行请求时发生了错误，也可能是web应用存在bug或某些临时的故障
        503 表示服务器暂时处于超负载或正在进行停机维护，无法处理请求
### web服务器
    一台web服务器可以搭建多个独立域名的web网站，也可以作为通信路径上的中转服务器提升传输效率，通过虚拟主机的功能，可以假想已具有多台服务器。
    同时部署在同一个服务器上的不同域名，使用DNS服务解析域名后，两者的访问IP地址会相同
    ** 通信数据转发程序——代理、网关、隧道**
        HTTP通信时，除客户端和服务器外，还有一些用于通信数据转发的应用程序：代理、网关、隧道，用以配合服务器工作
        这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端
        * 代理——有转发功能的应用程序，在客户端和服务器扮演中间人的角色，接收客户端发送的请求转发给服务器，同时也接收服务器返回的响应转发给客户端
            每次通过代理服务器转发请求或响应时，会追加写入Via首部信息
            理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等
            缓存代理——转发响应时，缓存代理会预先将资源的副本保存在代理服务器上，当代理再次收到对相同资源的请求时，可以不从源服务器那里获取资源，而是将之前缓存的资源作为相应返回
            透明代理——转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理，反之称为非透明代理
        * 网关——转发其他服务器通信数据的服务器，接收客户端的请求时，就像自己拥有资源的源服务器一样对请求进行处理
            利用网关可以由HTTP请求转化为其他协议通信，利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信线路上加密以确保连接的安全
        * 隧道——是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序
            隧道可按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信，隧道的目的是确保客户端能与服务器进行安全的通信，隧道本身不会解析HTTP请求，隧道会在通信双方断开连接时结束
    ** 缓存 **
        指代理服务器或客户端本地磁盘内保存的资源副本，可以减少对源服务器的访问，节省了通信流量和通信时间，二次响应时会向源服务器确认缓存资源的有效性
### HTTP首部
    ** HTTP通用首部字段——请求报文和响应报文双方都会使用的首部 **
        * Cache-Control——操作缓存的工作机制
            缓存请求指令
                |指令|参数|说明|
                |-|-|-|
                |no-cache|无|强制向源服务器再次验证|
                |no-store|无|不缓存请求或响应的任何内容|
                |max-age=[秒]|必需|响应的最大Age值|
                |max-stale(=[秒])|可省略|接收已过期的响应|
                |min-fresh=[秒]|必需|期望在指定时间内的响应仍有效|
                |no-transform|无|代理不可更改媒体类型|
                |only-if-cached|无|从缓存获取资源|
                |cache-extension|-|新指令标记(token)|
            缓存响应指令
                |指令|参数|说明|
                |-|-|-|
                |public|无|可向任意方提供响应的缓存|
                |private|可省略|仅向特定用户返回响应|
                |no-cache|可省略|缓存前必须确认其有效性|
                |no-store|无|不缓存请求或响应的任何内容|
                |no-transform|无|代理不可更改媒体类型|
                |must-revalidate|无|可缓存但必须再向源服务器进行确认|
                |proxy-revalidate|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
                |max-age=[秒]|必需|响应的最大Age值|
                |s-maxage=[秒]|必需|公共缓存服务器响应的最大Age值|
                |cache-extension|-|新指令标记(token)|
            `Cache-Control: public`当使用public指令时，则表明其他用户也可利用缓存
            `Cache-Control: private`当指定private指令时，响应只以特定的用户作为对象
            `Cache-Control: no-cache`使用no-cache的目的是为了防止从缓存中返回过期的资源，客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应，如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存
            `Cache-Control: no-cache=Location`由服务器返回的响应中，对no-cache具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存
            `Cache-Control: no-store`响应不被缓存，暗示请求或响应中包含机密信息
            `Cache-Control: s-maxage=[秒]/max-age=[秒]`如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源，当max-age的值为0，那么缓存服务器通常需要将请求转发给源服务器，当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认
            `Cache-Control: min-fresh=60[秒]`过了60秒的资源都无法作为响应返回
            `Cache-Control: max-stale=[秒]`如果未指定参数值，那么无论经过多久，客户端都会接受响应，如果指定了具体数据，那么即使过期，只要仍处于max-stale指定的时间内，仍旧会被客户端接收
            `Cache-Control: only-if-cached`表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性，若请求缓存服务器的本地缓存无响应，返回状态码504
            `Cache-Control: must-revalidate`代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效，若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504状态码，会忽略max-stale指令
            `Cache-Control: proxy-revalidate`要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性
            `Cache-Control: no-transform`规定无论在请求还是响应中，缓存都不能改变实体主体的媒体类型，可防止缓存或代理压缩图片等类似操作
        * Connection
            作用：控制不再转发给代理的首部字段和管理持久连接
            控制不再转发给代理的首部字段
            请求：GET / HTTP/1.1 Upgrade: xxx Connection: Upgrade，此时代理转发时会去掉Upgrade首部字段再发给源服务器
            HTTP/1.1版本的默认连接都是持久连接，客户端会在持久连接上持续发送请求，当服务器端想明确断开连接时，指定Connection: close
            HTTP/1.1之前的版本的默认连接都是非持久连接，如果想在旧版本上维持持久连接，指定Connection: Keep-Alive
        * Date
            首部字段Date表明创建HTTP报文的日期和时间
        * Pragma
            Pragma: no-cache属于通用首部字段，但只在客户端发送的请求中，要求所有的中间服务区不返回缓存的资源
        * Transfer-Encoding
            规定了传输报文主体时采用的编码方式，仅对分块传输有效Transfer-Encoding: chunked
    ** 请求首部字段 **
        请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容
        * Accept——通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级
            文本文件：text/plain、text/html、text/css、application/xhtml+xml、application/xml
            图片文件：image/jpeg、image/gif、image/png
            视频文件：video/mpeg、video/quicktime
            应用程序使用的二进制文件：application/octet-stream、application/zip
            想要给显示的媒体类型增加优先级，使用q=来表示权重，范围0-1(可精确到小数点后3位)，不指定默认权重是1.0，当服务器提供多种内容时，优先返回权重值最高的媒体类型，*/*表示任意类型
        * Accept-Charset来通知服务器用户代理支持的字符集及字符集的相对优先顺序(q)
        * Accept-Encoding来告知服务器用户代理支持的内容编码及优先级顺序，可一次性指定多种内容编码
            gzip
            deflate
            compress
            identity——不执行压缩或不会变化的默认编码格式
            *——指定任意的编码格式
        * Accept-Language——告知服务器用户代理能够处理的自然语言集
        * Authorization——验证信息
        * Host——虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分
        * If-xxx这种样式的请求首部字段，成为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求
            1. If-Match告知服务器匹配资源所用的实体标记(ETag)，当服务器上资源的ETag相同时会执行请求，也可以使用*指定If-Match字段值，服务器会忽略ETag值，只要资源存在就处理请求
            2. If-Modified-Since指定的日期时间后，资源发生了更新，服务器会接受请求
            3. If-None-Match的字段值和ETag值不一致时，处理该请求，与If-Match相反
            4. If-Range字段值若是跟ETag值或更新的日期时间匹配一致，就作为范围请求处理
            5. If-Unmodified-Since和If-Modified-Since的作用相反
        * Max-Forwards指定转发数值，每次转发数值减1，当为0时返回响应
        * Proxy-Authorization接收从代理服务器发来的认证质询
        * Range请求部分内容
        * Referer告知服务器请求的原始资源的URI
        * User-Agent将创建请求的浏览器和用户代理名称等信息传达给浏览器
    ** 响应首部字段 **
        * Accept-Ranges告知客户端服务器能否处理范围请求，可处理范围请求时指定其为bytes，反之其为none
        * Age: 600——告知客户端源服务器在多久前创建了响应，单位为秒
        * ETag告知客户端实体标识，是一种将资源以字符串形式做唯一性标识的方式
        * Location——可以将响应接收方引导至某个与请求URI位置不同的资源
        * Proxy-Authenticate会把代理服务器所要求的认证信息发给客户端
        * Retry-After——告知客户端在多久之后再次发送请求，可以指定时间或响应后的秒数
        * Server——告知客户端当前服务器上安装的HTTP服务器应用程序的信息
        * Vary——对缓存进行控制，当代理服务器接收到带有Vary首部字段指定获取资源的请求时，如果使用Accept-Language字段的值相同，那么直接从缓存返回响应，否则先从源服务器端获取资源后才能作为响应返回
        * WWW-Authenticate用于HTTP访问认证
    ** 实体首部字段 **
        * Allow——通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器收到不支持的方法是会返回405
        * Content-Encoding——告知客户端服务器对实体的主体部分选用的内容编码方式
        * Content-Language——告知客户端实体主体使用的自然语言    
        * Content-Length——表明实体主体部分的大小
        * Content-Location——给出与报文主体部分相对应的URI
        * Content-MD5——客户端会对接收的报文主体执行相同的MD5算法，然后和首部字段的Content-MD5的字段值比较，检查报文主体在传输过程中是否保持完整
        * Content-Range——返回响应时使用的首部字段，表示当前发送部分及整个实体大小
        * Content-Type——说明实体主体内对象的媒体类型
        * Expires——将资源失效的日期告知客户端，缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求
        * Last-Modified——指明资源最终修改的时间
### Cookie
    |首部字段名|说明|首部类型|
    |-|-|-|
    |Set-Cookie|开始状态管理所使用的Cookie信息|响应首部字段|
    |Cookie|服务器接收到的Cookie信息|请求首部字段|
    * Set-Cookie
        |属性|说明|
        |NAME=VALUE|赋予Cookie的名称和其值(必需项)|
        |expires=DATE|Cookie的有效期(若不明确指定则默认为浏览器关闭前为止)|
        |path=PATH|将服务器上的文件目录作为Cookie的适用对象(若不指定则默认为文档所在的文件目录)|
        |domain=域名|作为Cookie适用对象的域名(若不指定则默认为创建Cookie的服务器的域名)|
        |Secure|仅在HTTPS安全通信时才会发送Cookie|
        |HttpOnly|加以限制，使Cookie不能被js脚本访问|
        * expires属性——指定浏览器可发送Cookie的有效期，当省略时，有效期仅限于维持浏览器会话时间段内，通常是浏览器应用程序被关闭之前，另外一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie的方法，可以通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除
### 确保安全的HTTPS
    HTTP的缺点：通信使用明文，内容可能会被窃听、不验证通信方的身份，因此有可能遭遇伪装、无法证明报文的完整性，所以有可能已遭篡改
    加密技术：1、通信加密，可以通过和SSL或TLS组合使用，加密HTTP的通信内容，用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了；2、内容加密，对HTTP协议传输的内容本身加密后再发送，不是将整条通信线路加密，也有窃听风险
    HTTP协议不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下隐患：
        * 无法确定请求发送至目标的服务器是否是按真实意图返回响应的那台服务器，可能是已伪装的web服务器
        * 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端，可能是已伪装的客户端
        * 无法确定正在通信的双方是否具备访问权限，因为某些web服务器上保存着重要的信息，只想发给特定用户通信的权限
        * 无法判定请求是来自何方、出自谁手
        * 即使是无意义的请求也会照单全收，无法阻止DoS攻击
    查明对手的证书
        HTTP协议无法确定通信方，但是SSL可以，SSL使用了一种被称为证书的手段，可用于确定方，证书由第三方机构颁发
    HTTP协议无法证明通信的报文完整性，可能会遭受中间人攻击
    通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信
    加密技术：
        1. 共享密钥加密——加密密钥和解密密钥使用同一把密钥(有被窃听风险)
        2. 公开密钥加密——密文发送者使用公开密钥加密，密文接受者使用私有密钥解密
    HTTPS使用混合两种的方式，公开密钥加密比共享密钥加密处理速度要慢
    公开密钥遇到的问题：在公开密钥的传输途中，可能会被攻击者替换掉，解决方法：使用数字证书认证机构和其颁发的公开密钥证书
    HTTPS会消耗计算机的内存和CPU资源，因此通信会变慢
    Session管理和Cookie状态管理
        1. 客户端把用户ID和密码等登录信息放入报文的实体部分，通过POST方法把请求发送给服务器
        2. 服务器会发放用以识别用户的SessionID，通过验证从客户端发来的登录信息进行身份认证，然后把用户的认证状态与SessionID绑定后记录在服务器，服务器返回响应时，会在首部字段Set-Cookie内写入SessionID，为防止XSS，建议在Cookie内加上httponly属性
        3. 客户端接收到从服务器发来的SessionID后，将其作为Cookie保存在本地，下次再发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送，此时服务器通过验证接收到的SessionID识别用户
## 基于HTTP的功能追加
    * Comet——延迟应答，模拟实现服务器端向客户端推送的功能
        当请求来时，先挂起，等服务器端有内容更新时，再返回响应
        一次连接的持续时间变长了
    * WebSocket——通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据
        一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文
        优点: 1、推送功能——支持由服务器向客户端推送数据的推送功能，服务器可直接发送数据，不必等客户端请求；2、减少通信量——只要建立起WebSocket连接，就一直保持连接状态，和HTTP相比，每次连接时的总开销减少，而且WebSocket的首部信息很小，通信量也相应减少了